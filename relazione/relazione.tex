\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{float}
\usepackage{hyperref}
\usepackage[inkscapeformat=png]{svg}
\usepackage[margin=0.85in]{geometry}

\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black
}

\title{Swetify}
\author{Niccolò Malgeri, Filippo Viti, Alessio Delli Colli}
\date{July 2024}

\begin{document}

  \maketitle

  \tableofcontents
  \newpage


  \section{Introduzione}

  \subsection{Motivazioni}
  Il nostro intensivo utilizzo di piattaforme di streaming musicali ha suscitato in noi un interesse riguardo
  la loro struttura e il desiderio di replicarne il funzionamento.\\
  Abbiamo deciso quindi di realizzare un'applicazione che simuli le loro funzionalità da noi denominata Swetify.

  \subsection{Architettura dell'applicazione e pratiche utilizzate}


  \section{Requisiti}

  \subsection{Requisiti funzionali}
  \label{sec:reqFunc}
  Swetify prevede la partecipazione di due tipologie di utenti: cliente e artista.

  \subsubsection{Funzionalità proposte per il cliente}

  \begin{itemize}

    \item visualizzare un catalogo musicale che consenta agli utenti di cercare brani, album e artisti tramite una barra
    di ricerca.

    \item visualizzare le informazioni dettagliate di un brano, inclusi titolo, artista, album e durata.

    \item riprodurre, mettere in pausa e saltare i brani.

    \item creare, modificare ed eliminare le proprie playlist, aggiungere e rimuovere brani da queste playlist.

    \item ricevere raccomandazioni di brani basate sulla cronologia di ascolto dell'utente

    \item seguire gli artisti per ricevere aggiornamenti sui nuovi rilasci.

  \end{itemize}

  \subsubsection{Funzionalità proposte per l'artista}

  \begin{itemize}

    \item caricare album contenenti canzoni o podcast.

  \end{itemize}

  \subsection{Diagramma dei casi d'uso}

  Come accennato nella sezione \ref{sec:reqFunc}, ci sono due protagonisti, l'utente (\textbf{\textit{Customer}}) e l'artista (\textbf{\textit{Artist}}). La figura \ref{fig:useCaseDiagram} rappresenta il diagramma dei casi d'uso, questi ultimi corrispondenti ai requisiti funzionali descritti precedentemente.

  \begin{figure}[H]
    \centering
    \includesvg[width=0.7\linewidth]{UseCaseDiagram.svg}
    \caption{diagramma dei casi d'uso}
    \label{fig:useCaseDiagram}
  \end{figure}

  \subsection{Template dei casi d'uso}

  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \textbf{UC1}            & \textbf{riproduzione canzone}                               \\
      \hline
      livello                 & user goal                                                   \\
      \hline
      descrizione             & l'utente cerca e riproduce una canzone                      \\
      \hline
      attori                  & cliente                                                     \\
      \hline
      pre-condizioni          & l'utente deve avere le credenziali per effettuare l'accesso \\
      \hline
      post-condizioni         & la canzone selezionata viene aggiunta alla coda             \\
      \hline
      normale svolgimento     & 1) l'utente apre la pagina di ricerca                       \\
      & 2) inserisce il nome di una canzone                         \\
      & 3) seleziona una voce dall'elenco proposto                  \\
      & 4) seleziona l'opzione ``aggiungi in coda"

      \\
      \hline
      svolgimenti alternativi & 4b) l'utente seleziona l'opzione "aggiungi in testa"        \\
      \hline

    \end{tabular}

    \vspace{40pt}

    \begin{tabular}{|l|l|}
      \hline
      \textbf{UC2}            & \textbf{modifica playlist}                                  \\
      \hline
      livello                 & user goal                                                   \\
      \hline
      descrizione             & l'utente modifica una delle sue playlist personali          \\
      \hline
      attori                  & cliente                                                     \\
      \hline
      pre-condizioni          & l'utente deve avere le credenziali per effettuare l'accesso \\
      & ed avere una playlist salvata                               \\
      \hline
      post-condizioni         & la playlist presenta i cambiamenti apportati dall'utente    \\
      \hline
      normale svolgimento     & 1) l'utente apre la pagina "le mie playlist"                \\
      & 2) l'utente seleziona la playlist da modificare             \\
      & 3) l'utente cerca una canzone da aggiungere                 \\
      & 4) l'utente termina salvando le modifiche

      \\
      \hline
      svolgimenti alternativi & 3b) l'utente seleziona una canzone da rimuovere             \\
      & 4b) l'utente annulla le modifiche alla playlist             \\
      \hline

    \end{tabular}

    \vspace{40pt}

    \begin{tabular}{|l|l|}
      \hline
      \textbf{UC3}            & \textbf{aggiunta album}                                      \\
      \hline
      livello                 & user goal                                                    \\
      \hline
      descrizione             & l'artista carica un nuovo album sul suo profilo              \\
      \hline
      attori                  & artista                                                      \\
      \hline
      pre-condizioni          & l'artista deve avere le credenziali per effettuare l'accesso \\
      \hline
      post-condizioni         & il nuovo album è visibile se cercato dagli utenti            \\
      \hline
      normale svolgimento     & 1) l'artista seleziona l'opzione carica album                \\
      & 2) inserisce i nomi delle canzoni ed i rispettivi dati       \\
      & 3) l'artista termina l'inserimento salvando l'album
      \\
      \hline
      svolgimenti alternativi & 3b) l'artista annulla il caricamento dell'album              \\
      \hline

    \end{tabular}

    \vspace{40pt}

    \begin{tabular}{|l|l|}
      \hline
      \textbf{UC4}                     & \textbf{iscrizione ad un artista}                           \\
      \hline
      livello                          & user goal                                                   \\
      \hline
      descrizione                      & l'utente aggiunge un artista agli artisti seguiti           \\
      \hline
      attori                           & cliente                                                     \\
      \hline
      pre-condizioni                   & l'utente deve avere le credenziali per effettuare l'accesso \\
      \hline
      post-condizioni                  & nel momento in cui l'artista carica un nuovo album          \\
      & l'utente può visualizzarlo nella sezione                    \\
      & "nuovi rilasci"                                             \\
      \hline
      normale svolgimento \hspace{5pt} & 1) l'utente apre la pagina di ricerca                       \\
      & 2) inserisce il nome di una canzone                         \\
      & 3) seleziona una voce dall'elenco proposto                  \\
      & 4) seleziona l'opzione ``aggiungi in coda"
      \\
      \hline


    \end{tabular}
  \end{center}

  \newpage

  \subsection{Mockups}
  \subsubsection{Pagina di accesso}
  \begin{figure}[H]
    \includegraphics[scale=0.25]{welcome}
  \end{figure}
  \subsubsection{Pagina di ricerca}
  \begin{figure}[H]
    \includegraphics[scale=0.25]{search}
  \end{figure}
  \subsubsection{Suggerimenti}
  \begin{figure}[H]
    \includegraphics[scale=0.25]{suggestions}
  \end{figure}
  \subsubsection{Coda di riproduzione}
  \begin{figure}[H]
    \includegraphics[scale=0.25]{playback}
  \end{figure}

  \subsection{Sequence diagram}
  \begin{figure}[H]
    \includegraphics[scale=0.30]{sequenze01}
  \end{figure}

  \section{Scelte di progetto}

  Abbiamo scelto di strutturare il progetto creando una divisione tra domain model, business logic e data
  access objects.
  \begin{itemize}
    \item
    Il package  \textbf{domainmodel} definisce le classi che simboleggiano gli elementi con cui l'utente
    interagisce.
    \item
    il package \textbf{businesslogic} descrive le modalità e le possibilità di interazione che l'utente
    ha con tali oggetti.
    \item
    il \textbf{dao} garantisce la persistenza di alcuni oggetti all'interno dell'applicazione.

  \end{itemize}


  \section{Implementazione}

  \subsection{Domain model}

  \begin{figure}[H]
    \includegraphics[scale=0.4]{model01}
  \end{figure}

  \subsubsection{BaseEntity}
  Classe base astratta che garantisce la presenza di un ID in tutte entità concrete.
  \subsubsection{Customer}
  Rappresenta il cliente e contiene le sue credenziali di accesso oltre alle playlist salvate. // TODO: decidere se fare inversione
  \subsubsection{Artist}
  Rappresenta l'artista e contiene le sue credenziali d'accesso e gli album da lui caricati. // TODO: sus
  \subsubsection{Track}
  Rappresenta una traccia audio che può essere aggiunta alla coda\\ di riproduzione.

  \subsection{DurationConverter}
  Implementa l'interfaccia AttributeConverter di Jakarta per convertire la durata delle Track dal tipo Duration a un tipo supportato dal DBMS.
  \subsubsection{Song}
  Concretizzazione di Track che rappresenta una canzone.
  \subsubsection{Podcast}
  Concretizzazione di Track che rappresenta un podcast.
  \subsubsection{Playlist}
  Rappresenta una playlist generica ed espone i metodi per aggiungere o rimuovere\\ delle track in testa oppure in coda.

  \subsubsection{SongPlaylist}
  Rappresenta una playlist a cui possono essere aggiunte soltanto canzoni

  \subsubsection{PodcastPlaylist}
  Rappresenta una playlist a cui possono essere aggiunti soltanto podcast
  \subsubsection{Album}
  Incapsula una playlist di cui espone selettivamente soltanto i metodi di lettura, in modo da rendere immutabile la lista di canzoni dopo che è stata creata.
  \subsubsection{PlaybackQueue}
  Rappresenta la coda di riproduzione e permette di aggiungere in testa ed in coda oltre ad eliminare in testa. Non è persistente.

  \subsubsection{TrackPlaysCount}
  Classe astratta che associa un Customer a ogni Track che ha ascoltato mantenendo un conteggio del numero di riproduzioni. Questa informazione serve per il calcolo delle tracce suggerite.

  \subsubsection{SongPlaysCount}
  Concretizzazione di TrackPlaysCount che conta quante volte un utente ha riprodotto ogni canzone

  \subsubsection{PodcastPlaysCount}
  Concretizzazione di TrackPlaysCount che conta quante volte un utente ha riprodotto ogni canzone

  \subsubsection{TrackPlaysCountListener}
  Trigger che mantiene aggiornato il numero totale di riproduzioni di una traccia.

  \subsection{Business logic}

  \begin{figure}[H]
    \includegraphics[scale=0.28]{logic01}
  \end{figure}

  \subsubsection{Handler}
  Classe base astratta che rappresenta un handler generico.\\
  Essa garantisce la presenza di un metodo update in ogni handler che contiene la logica di quest'ultimo.
  \subsubsection{State}
  Classe che permette ai vari handler di comunicare tra loro dati come
  l'utente loggato, la canzone o la playlist selezionata
  \subsubsection{NavigationManager}
  Gestisce la navigazione tra le pagine passando il controllo ai vari handler.
  \subsubsection{AlbumsHandler}
  Permette di visualizzare o riprodurre un album.
  \subsubsection{ArtistInfoHandler}
  Mostra le informazioni salienti di un artista.
  \subsubsection{HomeHandler}
  Contiene la schermata di ingresso e instrada l'utente verso le varie pagine.
  \subsubsection{LoginHandler}
  Permette all'utente di effettuare l'accesso con un nome utente e una password o
  eventualmente passare alla schermata di registrazione.
  \subsubsection{PlaybackHandler}
  Gestisce la coda di riproduzione e permette all'utente di visualizzare i
  brani contenuti in essa.
  \subsubsection{PlaylistHandler}
  Mostra all'utente i brani contenuti in una data playlist e permette ad esso di
  aggiungerla alla coda di riproduzione.
  \subsubsection{RegistrationHandler}
  Permette all'utente di registrarsi all'interno dell'applicazione con un
  nome utente ed una password.
  \subsubsection{SearchHandler}
  Gestisce la ricerca all'interno delle canzoni, dei podcast e degli artisti disponibili.
  \subsubsection{SuggestionsHandler}
  Mostra all'utente le track suggerite dall'applicazione.
  \subsubsection{UserPlaylistsHandler}
  Mostra l'elenco delle playlist create dall'utente.

  \subsection{DAO}

  \begin{figure}[H]
    \includegraphics[scale=0.3]{dao01}
  \end{figure}

  \subsubsection{BaseDAO}
  Classe base generica del Data Access Object che definisce i metodi CRUD di base per interfacciarsi col DBMS.
  Oltre ai CRUD di una singola entità è implementato anche un metodo per ottenere l'intera tabella. I metodi per eseguire filtraggi sulla base di parametri specifici sono definiti nelle classi derivate.

  \subsubsection{CustomerDAO}
  Permette di ottenere oggetti Customer dal database a patire dal loro username.

  \subsubsection{ArtistDAO}
  Permette di ottenere oggetti Artist dal database a patire dal loro nome d'arte o username.

  \subsubsection{SongDAO}
  Permette di ottenere oggetti Song dal database in base a una parola chiave o un Artist.

  \subsubsection{PodcastDAO}
  Permette di ottenere oggetti Podcast dal database in base ad una parola chiave o un Artist.

  \subsubsection{SongPlaylistDAO}
  Permette di ottenere oggetti SongPlaylist dal database in base al titolo.

  \subsubsection{PodcastPlaylistDAO}
  Permette di ottenere oggetti PodcastPlaylist dal database in base al titolo.

  \subsubsection{AlbumDAO}
  Permette di ottenere oggetti Album dal database in base al titolo o all'autore

  \subsubsection{SongPlaysCountDAO}
  Permette di aggiornare nel database il conteggio delle riproduzioni di una canzone.

  \subsubsection{PodcastPlaysCountDAO}
  Permette di aggiornare nel database il conteggio delle riproduzioni di un podcast.

  \subsubsection{SuggestionDAO}
  Permette, dato un utente, di ottenere una lista di canzoni suggerite in base a cosa hanno ascoltato utenti con preferenze affini.


  \section{Test}

  \subsection{Tipologie di test effettuati e organizzazione}

  Per poter garantire il corretto funzionamento di \textit{Swetify} sono stati effettuate due tipologie di test:
  \begin{itemize}
    \item \textbf{test di integrazione}: verificano il comportamento che le componenti dell'applicazione mostrano quando interagiscono tra di loro; nello specifico, vengono testate le operazioni che i DAO utilizzano per interagire con il database di sistema
    \item \textbf{test funzionali}: verificano il comportamento delle singole componenti dell'applicazione in un possibile scenario reale in cui quest'ultima viene utilizzata. Tra i test funzionali rientrano, per esempio, quelli relativi alla navigazione tra una schermata e l'altra dell'applicazione
  \end{itemize}

  \begin{figure}[H]
    \centering
    \includesvg[width=0.85\linewidth]{TestsUML.svg}
    \caption{struttura del package \textit{Test}}
    \label{fig:testsUML}
  \end{figure}

  In figura \ref{fig:testsUML} viene mostrata l'organizzazione delle classi di test, contenute nel package \textit{Test}. Come si può notare, è presente una classe base \textbf{\textit{BaseTest}} contenente le funzionalità comuni a tutte le altre classi, come la funzione \textbf{\textit{setUp()}}; questa funzione serve per ripulire il database tra un test e l'altro, motivo per il quale viene eseguita prima di ciascun test.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{setUp.png}
    \caption{esempio di implementazione di \textit{setUp()} (in questo caso relativa a SongDAOTest)}
    \label{fig:setUp}
  \end{figure}


  Come si può vedere in figura \ref{fig:setUp}, la \textit{setUp()} della classe base viene chiamata all'inizio della \textit{setUp()} delle classi
  derivate, seguita dall'inizializzazione del database e degli oggetti necessari per l'esecuzione dei test.

  Per la scrittura di tutti i test è stato utilizzato il framework \textbf{\textit{Junit 5.0}}.

  \subsection{Test di integrazione}
  Di seguito vengono descritti i metodi presenti nelle classi relative ai test di integrazione; ogni metodo consiste nel verificare il comportamento di una specifica query, scritta in linguaggio SQL, per l'accesso al database.


  \subsubsection{SongDAOTest}
  \begin{itemize}

    \item \textbf{\textit{testGet()}}: verifica che \textit{SongDAO.getByTitle()} e \textit{SongDAO.get()} restituiscano lo stesso risultato, confrontando i titoli delle canzoni (oggetti di tipo \textit{Song}) restituite

    \item \textbf{\textit{testGetByTitle()}}: prima viene verificata la presenza di alcuni oggetti di tipo \textit{Song} salvati precedentemente sul database, attraverso \textit{SongDAO.getByTitle()}; successivamente, viene creato un nuovo oggetto \textit{song} di tipo \textit{Song} senza però salvarlo, e viene verificata l'assenza di risultati restituiti da \textit{SongDAO.getByTitle(song.getTitle())}

    \item \textbf{\textit{testGetAll()}}: verifica che \textit{SongDAO.getAll()} restituisca il giusto numero di risultati, sulla base di quanti oggetti di tipo \textit{Song} sono presenti nel database

  \end{itemize}

  \subsubsection{ArtistDAOTest}
  \begin{itemize}

    \item \textbf{\textit{testGet()}}: verifica che \textit{ArtistDAO.getByStageName()} e \textit{ArtistDAO.get()} restituiscano lo stesso risultato, confrontando nome, numero di seguaci e biografia degli artisti (oggetti di tipo \textit{Artist}) restituiti

    \item \textbf{\textit{testGetByUserName()}}: prima viene verificata la presenza di alcuni oggetti di tipo \textit{Artist} salvati precedentemente sul database, attraverso \textit{ArtistDAO.getByUserName()}; successivamente, viene creato un nuovo oggetto \textit{artist} di tipo \textit{Artist} senza però salvarlo, e viene verificata l'assenza di risultati restituiti da\textit{ArtistDAO.getByUserName(artist.getUsername())}

    \item \textbf{\textit{testByStageName()}}: dopo aver creato e salvato due nuovi oggetti di tipo \textit{Artist} con lo stesso nome di uno degli artisti presenti nel database, verifica che \textit{ArtistDAO.getByStageName()} restituisca il giusto numero di risultati

    \item \textbf{\textit{testGetAll()}}: prima verifica che \textit{ArtistDAO.getAll()} restituisca il giusto numero di risultati, sulla base di quanti oggetti di tipo \textit{Artist} sono presenti nel database, e successivamente verifica che tali risultati siano corretti, controllando nome, numero di seguaci e biografia per ciascuno di essi

  \end{itemize}

  \subsubsection{CustomerDAOTest}
  \begin{itemize}

    \item \textbf{\textit{testGet()}}: verifica che \textit{CustomerDAO.getByStageName()} e \textit{CustomerDAO.get()} restituiscano lo stesso risultato, confrontando nome utente e password dei customer (oggetti di tipo \textit{Customer}) restituiti

    \item \textbf{\textit{testGetByUserName()}}: prima viene verificata la presenza di alcuni oggetti di tipo \textit{Customer} salvati precedentemente sul database, attraverso \textit{CustomerDAO.getByUserName()}; successivamente, viene creato un nuovo oggetto \textit{user} di tipo \textit{Customer} senza però salvarlo, e viene verificata l'assenza di risultati restituiti da\textit{CustomerDAO.getByUserName(user.getUsername())}

    \item \textbf{\textit{testGetAll()}}: prima verifica che \textit{CustomerDAO.getAll()} restituisca il giusto numero di risultati, sulla base di quanti oggetti di tipo \textit{Customer} sono presenti nel database, e successivamente verifica che tali risultati siano corretti, controllando nome utente e password per ciascuno di essi

  \end{itemize}


  \subsubsection{SuggestionDAOTest}
  \begin{itemize}
    \item
    \textbf{\textit{testSuggestions()}}: verifica che la query effettuata dalla funzione
    \textit{getTopSongsBySimilarUsers()} della classe \textit{SuggestionDAO} sia conforme alla logica desiderata
    calcolando in maniera indipendente il risultato atteso grazie alle funzioni \textit{getUserTopTen()},
    \textit{getCustomersWhoListenedTopTenSongs()}, \textit{getTopTenSongsByTopTenListeners()}.
  \end{itemize}

  \subsubsection{SongPlaylistDAOTest}

  \subsubsection{PodcastPlaylistDAOTest}

  \subsubsection{SongPlaysCountDAOTest}

  \subsection{Test funzionali}

  Come per i test di integrazione, di seguito vengono descritti i metodi presenti nelle classi relative ai test funzionali; nella \textit{setUp()} di ciascun metodo viene inizializzato il \textit{NavigationManager} e viene chiamato il metodo \textit{pushHandler()} specificando l'identificativo dell'handler coinvolto nei test all'interno di una certa classe. Lo scenario di utilizzo dell'applicazione è rappresentato da un oggetto di tipo \textit{ByteArrayInputStream} contenente la sequenza di input da testare; un esempio di sequenza testata è mostrata in figura \ref{fig:testString}

  \begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{testString.png}
    \caption{esempio di sequenza di input testata}
    \label{fig:testString}
  \end{figure}

  \subsubsection{HomeHandlerTest}

  \begin{itemize}

    \item \textbf{\textit{testHomeSearch()}}: verifica la navigazione dalla homepage alla pagina di ricerca, confrontando l'identificativo dell'ultimo Handler che ha chiamato l'\textit{update()} con quello di \textit{SearchHandler}

    \item \textbf{\textit{testHomeViewPlaylists()}}: verifica la navigazione dalla homepage alla pagina di visualizzazione delle playlist di un utente, confrontando l'identificativo dell'ultimo Handler che ha chiamato l'\textit{update()} con quello di \textit{UserPlaylistsHandler}

    \item \textbf{\textit{testHomeSuggestions()}}: verifica la navigazione dalla homepage alla pagina di visualizzazione dei suggeriti, confrontando l'identificativo dell'ultimo Handler che ha chiamato l'\textit{update()} con quello di \textit{SuggestionHandler}

  \end{itemize}

  \subsubsection{PlaybackHandlerTest}:
  \begin{itemize}

    \item \textbf{\textit{testInitialPlaybackState()}}: verifica che lo stato iniziale della coda di riproduzione sia corretto. In particolare,
    dopo aver inserito una canzone \textit{song} nella coda di riproduzione, verifica che il thread in esecuzione rappresentante la coda stessa sia attivo (con il metodo \textit{Thread.isAlive()}) e che \textit{song} sia in pausa

    \item \textbf{\textit{testPlayPauseFunctionality()}}: verifica la funzionalità di pausa di una canzone, controllando se il thread relativo alla coda sia in esecuzione (se una canzone è in riproduzione) oppure no

    \item \textbf{\textit{testSkipFunctionality()}}: verifica la funzionalità di skip di una canzone

    \item \textbf{\textit{testTrackSwitching()}}: verifica che la coda di riproduzione passi correttamente da una canzone in riproduzione alla successiva; in particolare, controlla che la successiva canzone nella coda sia in riproduzione dopo che quella corrente è terminata

  \end{itemize}

  \subsubsection{RegistrationLoginHandlersTest}
  \begin{itemize}
    \item \textbf{\textit{testRegistrationCustomer()}}:
    dopo aver aggiunto un utente (oggetto di tipo \textit{Customer}) al database, verifica che sia effettivamente presente attraverso \textit{CustomerDAO.getByUsername()} e che ce ne sia uno solo

    \item \textbf{\textit{testRegistrationArtist()}}:
    dopo aver aggiunto un artista (oggetto di tipo \textit{Artist}) al database, verifica che sia effettivamente presente attraverso \textit{ArtistDAO.getByUsername()} e che ce ne sia uno solo

    \item \textbf{\textit{testLoginCustomer()}}: dopo aver aggiunto un utente (oggetto di tipo \textit{Customer}) al database e dopo aver fatto registrazione e login, verifica che nome e password di tale utente corrispondano a quelli memorizzati nella sessione corrente

    \item \textbf{\textit{testLoginArtist()}}: dopo aver aggiunto un artista (oggetto di tipo \textit{Artist}) al database e dopo aver fatto registrazione e login, verifica che nome e password di tale artista corrispondano a quelli memorizzati nella sessione corrente

  \end{itemize}

  \subsubsection{AlbumLoadHandlerTest}
  \begin{itemize}
    \item \textbf{\textit{testSuccessfulAlbumLoad()}}: dopo aver creato un album contenente una sola canzone, verifica che tale canzone sia presente e che sia effettivamente l'unica al suo interno
  \end{itemize}



\end{document}
